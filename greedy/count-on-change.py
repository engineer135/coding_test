"""
greedy(탐용법) 알고리즘 - 현재 상황에서 가장 좋은 것만 고르는 방법.

그리디 문제는 가장 큰 순서대로, 가장 작은 순서대로와 같은 기준을 넌지시 제시해준다.

■ 거스름돈 예제
금액 N 받았을때,
500, 100, 50, 10원으로 거스름돈을 주는 경우
거슬러줄 동전의 최소 개수(total) 구하기

큰돈부터 순서대로 거슬러주면, 최소한의 개수가 나온다.
"""

n = 1260 # 거슬러줘야할 돈
count = 0
coins = [500, 100, 50, 10] # 거스름돈. 큰 단위 화폐부터 차례대로 확인.

for coin in coins:
    count += n // coin # 몫이 동전의 개수. 바로 count에 추가함.
    n = n % coin # 나머지로 거스름돈 다시 셋팅

print("동전 개수: ",count)

"""
거슬러줄 화폐의 종류만큼 반복을 수행한다.
화폐 종류가 K개일때 시간 복잡도는 O(K)이다.

이 문제에서는 화폐 단위가 큰 단위가 작은 단위의 배수 형태이므로 정당한 해법이지만,
화폐 단위가 500, 400, 100원인 경우처럼 작은 단위의 동전들을 종합해 다른 해가 나올 수 있는 경우에는 그리디 알고리즘으로 풀수 없다.
ex) n = 800 이면, 그리디로는 500+100+100+100 = 4개지만, 실제로는 400+400 = 2개가 정답이다.

처음에는 그리디 알고리즘을 생각해보자.
문제 해결이 안된다면 다이내믹 프로그래밍이나 그래프 알고리즘 등으로 생각을 확장해볼 필요 있음.
"""
